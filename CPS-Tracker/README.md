# CPS-Tracker

## Fear and logging
At first they asked a few questions which are in section IV. Provthings,
Completeness: The system should ans “How was the data generated by my sleep sensor used?” and “What triggered my front door to unlock?”
Applicability: To satisfy applicability, the framework should be adaptable with modest changes to the broad variety of IoT platforms listed in Table I.
Minimality: To achieve minimality, it should require few or no changes to the semantics of the IoT platform, or to the platform itself

All of those 3 points are also satisfied with the testbed system.

In the implementation - section V, what they didn't consider is following,
As shown in Algorithm 1, code that was not on any control-
flow path from the entry points to the sinks was not instru-
mented as it did not affect the behavior of sinks. However, in
the case of SmartApps we did identify two exceptions. One
exception was dynamic method invocation. Since a dynamic
method invocation could invoke any method in the SmartApp
at runtime, we instrumented code to track this call. We further
discuss the implication of it in §VIII. The other exception
was assignment to global variables as they are shared among
executions. If a global variable has been assigned data that
could be derived from sources and the variable has been used
by sinks, the code in the control-flow path from entry points
to the assignment statement also needs to be instrumented to
track the provenance of the data.


Acoording to the above text and the Fig. 8, they instrumented only function calls with argument name and argument value and the global variables. They didn't consider the conditions. As they say,
Figure 8 shows some of the helper
functions: entryMethod , trackVarAssign and trackSink ,
which track provenance of program entry point invocation,
variable assignment and sink invocation respectively.

I am not sure if we did the trackVarAssign and trackSink. With my minimal knowledge, I think the trackVarAssign means if the parameter is passed to the function and that's changed which is triggering an event and the trackSink can be the caller of the function. If that's the case, then we did it.

For the motivation, as we discussed if we log only the function calls and the global variables then we can't see the attack. But I think still it's possible to identify the attack because in our model we are generating the table and the events with the function calls and from global variables. I am not sure how to make a good motivation in the paper.

#### The attacks and solution

1. The dynamic method(attack) invocation can solved by the testbed model as well. As they say,
Unlock door: The attack function in
LockItWhenILeave , on the other hand, was triggered by a
timer that was set while handling a mode change event that
was generated by the setLocationMode function invoked
by WhenEveryoneIsAway .

Solution(notifying the admin): That function is triggered by the timer. In reagards of this attack, in Figure 11 they introduced a policy, where they show how they solved the problem(notifying the admin),
SINK is a label
representing sink activities, Reflection represents a dynamic
method invocation activity. The policy specifies that if a sink
was invoked using dynamic method invocation and the value
was from an external HTTP input, ProvThings will notify
Admin of the activity.

2. Sensitive data leak: FaceDoor is an app
that allows unlocking a door via face recognition using the
front door camera. However, a malicious payload in FaceDoor
(see Appendix C for details) steals user’s sensitive information
and sends it to an attacker at midnight every day. It leverages
a privilege escalation vulnerability in SmartThings [44] that
permits a SmartApp to subscribe to all events generated by
a device once the user has authorized the app to access the
device. In this case, FaceDoor subscribes all the events of the
motion sensor, front door lock, front door camera and location.
Hence, it could steal sensitive information such as pin codes
from codeReport events, users’ photos from image events
and the mode of the home from mode events. Figure 12 shows a provenance graph of how some sensitive
data was leaked by FaceDoor .

Solution: The information flow is not from a trusted source - fig 13.

3. Fake alarm attack: in this case, we consider a user installed a
benign app ( SmokeMonitor ) which monitors the events of
a smoke detector. If there is smoke detected by the smoke
detector, SmokeMonitor will turn on the fire sprinkler, open
the window and sound the alarm. Another app ( SmartLight )
which is embedded with malicious payload could raise a fake
physical device event for the smoke detector which will misuse
the logic of SmokeMonitor to take multiple actions. Figure 14. The fake event was generated by the
createFakeEvent method of SmartLight , while the real
event was generated by parsing a device message from the
smoke sensor.

#### In our case, what we have is following
1. Moving the Hbw to grab a workpiece without any prior message
   Sol: It was called without previou sequence
2. The storage information leak and changed in hbw - similar to sensitive data leak
   Sol: We don't see the update in the table
3. Fake sensor attack on VGR - similar to Fake alarm attack
   Sol: We don't see the nfc read, write and type of data

We don't anything similar to the unlock door attack. But we have similar attack

Solution(WhyThis app is used): In Figure 15, we show screenshots of our simplified
frontend, the WhyThis app, for typical consumers.

## APT attacks
An Advanced Persistent Threat (APT) attack refers to a prolonged, targeted cyber attack that is carried out by a sophisticated adversary with specific objectives. **APT attacks typically involve a combination of various techniques and tools to gain unauthorized access, maintain persistence, and exfiltrate sensitive data over an extended period of time.**
Persistence: APT attacks are typically long-term and persistent in nature, with the attacker attempting to maintain their presence within the target network or system over an extended period of time.
Advanced Techniques: APT attacks often involve advanced techniques and tools, including zero-day exploits, custom malware, social engineering, and targeted phishing emails. Attackers may leverage sophisticated tactics to evade detection and bypass security measures.
Covert Operations: APT attackers aim to remain undetected by blending into the normal network activity, using techniques such as lateral movement, privilege escalation, and encryption to hide their actions.

## False Data Injection:

In False Data Injection (FDI) an adversary maliciously injects fabricated or manipulated data into a system or network. Purpose of this attack is to deceive or manipulate the behavior of the targeted system, leading to incorrect decisions, compromised operations, or compromised integrity of the data.
**This could involve modifying sensor readings, altering data packets, or manipulating the input signals to deceive the system.**

[In testbed, it starts with this check](https://github.com/fischertechnik/txt_training_factory/blob/master/TxtSmartFactoryLib/src/TxtVacuumGripperRobotRun.cpp#L192-L195),
```
		else if (!dps.is_DIN())
		//else if(!block)
		{
			FSM_TRANSITION( START_DELIVERY, color=blue, label='dsi' );
		}
```
This `dps.is_DIN()` function is defined in the `TxtDeliveryPickupStation.cpp` [file](https://github.com/fischertechnik/txt_training_factory/blob/master/TxtSmartFactoryLib/src/TxtDeliveryPickupStation.cpp#L117-L129), 
```
	bool TxtDeliveryPickupStation::is_DIN()
	{
		std::cout<<"Function: TxtDeliveryPickupStation::is_DIN()\n";
		SPDLOG_LOGGER_TRACE(spdlog::get("console"), "is_DIN", 0);
		assert(pT->pTArea);
		return (pT->pTArea->ftX1in.uni[6] == 1);
	}
```

**[Note:Most important thing to notice here this function `is_DIN()` will return `false or 0`. But the condition will check if it's not `true or 1`. So, if I print the values then I should get `0`. That's what I got in the log.]** See the following,

```
Function: _ZN2ft21TxtVacuumGripperRobot7fsmStepEv
Global Variable:   %235 = load i8, i8* %234, align 1, !dbg !25748, !tbaa !25750, !range !25663
loadInst_values: 0
Global Variable:   %249 = load i8, i8* %248, align 4, !dbg !25761, !tbaa !25763, !range !25663
loadInst_values: 0
Global Variable:   %268 = load i8, i8* %267, align 4, !dbg !25775, !tbaa !25776, !range !25663
loadInst_values: 0
Global Variable:   %313 = load i8, i8* %312, align 1, !dbg !25815, !tbaa !25662, !range !25663
loadInst_values: 0
Function: _ZN2ft24TxtDeliveryPickupStation6is_DINEv
Called from: _ZN2ft21TxtVacuumGripperRobot7fsmStepEv _ZN2ft24TxtDeliveryPickupStation6is_DINEv callInst_values: 0
Function: _ZNSt6chrono8durationIxSt5ratioILx1ELx1000EEEC2IivEERKT_
Function: _ZNSt11this_thread9sleep_forIxSt5ratioILx1ELx1000EEEEvRKNSt6chrono8durationIT_T0_EE
Function: _ZNSt6chrono8durationIxSt5ratioILx1ELx1000EEE4zeroEv
Function: _ZNSt6chrono15duration_valuesIxE4zeroEv
Function: _ZNSt6chrono8durationIxSt5ratioILx1ELx1000EEEC2IxvEERKT_
Function: _ZNSt6chronoleIxSt5ratioILx1ELx1000EExS2_EEbRKNS_8durationIT_T0_EERKNS3_IT1_T2_EE
Function: _ZNSt6chronoltIxSt5ratioILx1ELx1000EExS2_EEbRKNS_8durationIT_T0_EERKNS3_IT1_T2_EE
Function: _ZNKSt6chrono8durationIxSt5ratioILx1ELx1000EEE5countEv
Function: _ZNKSt6chrono8durationIxSt5ratioILx1ELx1000EEE5countEv
Called from: _ZNSt11this_thread9sleep_forIxSt5ratioILx1ELx1000EEEEvRKNSt6chrono8durationIT_T0_EE _ZNSt6chronoleIxSt5ratioILx1ELx1000EExS2_EEbRKNS_8durationIT_T0_EERKNS3_IT1_T2_EE callInst_values: 0
```
![FID detection](https://github.com/mdrahmed/cheatsheets/assets/26908164/a50fa093-26e2-4882-a712-51e92ecbd9f5)


See the function is called first and then inside the condition the value is `false`.
```
Function: _ZN2ft24TxtDeliveryPickupStation6is_DINEv
Called from: _ZN2ft21TxtVacuumGripperRobot7fsmStepEv _ZN2ft24TxtDeliveryPickupStation6is_DINEv callInst_values: 0
```


**False Data Injection: To perform this attack, we will insert malicious data inside the code. Which will trigger [this particular code](https://github.com/fischertechnik/txt_training_factory/blob/master/TxtSmartFactoryLib/src/TxtVacuumGripperRobotRun.cpp#L194) or, we will directly [call this case](https://github.com/fischertechnik/txt_training_factory/blob/master/TxtSmartFactoryLib/src/TxtVacuumGripperRobotRun.cpp#L350),**
```
	FSM_TRANSITION( START_DELIVERY, color=blue, label='dsi' );
```
Or,
```
	case START_DELIVERY:
	{
		printState(START_DELIVERY);

		setTarget("hbw");
		moveDeliveryInAndGrip();
		moveNFC();
		std::string uid = dps.nfcReadUID();
		if (uid.empty())
		{
			FSM_TRANSITION( WRONG_COLOR, color=red, label='empty tag' );
			break;
		} else {
			proStorage.resetTagUidMaskTs(uid);
			proStorage.setTimestampNow(uid, DELIVERY_RAW_INDEX);
			if (reqWP_HBW != 0) {
				reqWP_HBW->printDebug();
				delete reqWP_HBW;
			}
			reqWP_HBW = new TxtWorkpiece(uid,WP_TYPE_NONE,WP_STATE_RAW);
			reqWP_HBW->printDebug();
			FSM_TRANSITION( COLOR_DETECTION, color=blue, label='nfc tag ok' );
		}
#ifdef __DOCFSM__
		FSM_TRANSITION( START_DELIVERY, color=blue, label='wait' );
#endif
		break;
	}
```


**If we do that then we will not see the Function call, so according to that we or, the administrator can tell that's an attack.** 
```
Function: _ZN2ft24TxtDeliveryPickupStation6is_DINEv
```

**To replace the sensor data:**
Write script to intercept the data stream, modify the sensor data, and send the altered data to the system using python.
Intercept the MQTT messages passing through the middleware and modify the relevant data fields before forwarding them to the system. I can use wireshark/python for this. 

